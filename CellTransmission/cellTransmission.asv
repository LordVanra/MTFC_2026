function distanceMatrix = load_distance_matrix(filepath, cellIDs)
    nCells = length(cellIDs);
    distanceMatrix = zeros(nCells, nCells);
    
    % Read CSV file
    data = readtable(filepath);
    
    % Convert cell IDs to strings for matching
    cellIDsStr = string(cellIDs);
    
    % Fill distance matrix
    for i = 1:nCells
        for j = 1:nCells
            % Find row index matching cell i
            rowIdx = find(strcmp(string(data{:,1}), cellIDsStr(i)));
            
            if ~isempty(rowIdx) && width(data) > j
                distanceMatrix(i,j) = data{rowIdx, j+1};
            end
        end
    end
end

function cellLengths = calculate_cell_lengths(distanceMatrix)
    nCells = size(distanceMatrix, 1);
    cellLengths = zeros(nCells, 1);
    
    for i = 1:nCells
        % Get non-zero distances from this cell
        nonZeroDist = distanceMatrix(i, distanceMatrix(i,:) > 0);
        
        if ~isempty(nonZeroDist)
            % Use average distance to connected cells
            cellLengths(i) = mean(nonZeroDist);
        else
            % Default length if no connections
            cellLengths(i) = 1.0; 
        end
    end
end

function sendingFlow = compute_sending_flow(vehicles, cellLength, criticalVehicles, params)

    if vehicles <= criticalVehicles
        % Free flow regime
        sendingFlow = params.freeFlowSpeed * vehicles / cellLength;
    else
        % Congested regime - flow at capacity
        sendingFlow = params.maxFlow;
    end
    
    % Convert from vehicles/hour to vehicles/time_step
    sendingFlow = sendingFlow * (params.timeStep / 3600.0);
end

function receivingFlow = compute_receiving_flow(vehicles, cellLength, maxVehicles, criticalVehicles, params)
    if vehicles < criticalVehicles
        % Can receive at maximum flow
        receivingFlow = params.maxFlow;
    else
        % Limited by congestion wave speed
        receivingFlow = params.congestionWaveSpeed * (maxVehicles - vehicles) / cellLength;
    end
    
    % Convert from vehicles/hour to vehicles/time_step
    receivingFlow = receivingFlow * (params.timeStep / 3600.0);
end

function flowMatrix = compute_flows(currentVehicles, cellLengths, maxVehicles, criticalVehicles, distanceMatrix, params)

    nCells = length(currentVehicles);
    flowMatrix = zeros(nCells, nCells);
    
    % Compute flows for each connection
    for i = 1:nCells
        for j = 1:nCells
            if distanceMatrix(i,j) > 0  % Connection exists
                % Get sending capacity of upstream cell
                sendCap = compute_sending_flow(currentVehicles(i), ...
                                              cellLengths(i), ...
                                              criticalVehicles(i), ...
                                              params);
                
                % Get receiving capacity of downstream cell
                recvCap = compute_receiving_flow(currentVehicles(j), ...
                                                cellLengths(j), ...
                                                maxVehicles(j), ...
                                                criticalVehicles(j), ...
                                                params);
                
                % Actual flow is minimum of sending and receiving
                flowMatrix(i,j) = min(sendCap, recvCap);
            end
        end
    end
    
    % Normalize if a cell sends to multiple downstream cells
    for i = 1:nCells
        totalOutflow = sum(flowMatrix(i,:));
        sendCap = compute_sending_flow(currentVehicles(i), ...
                                      cellLengths(i), ...
                                      criticalVehicles(i), ...
                                      params);
        
        if totalOutflow > sendCap
            % Scale down proportionally
            flowMatrix(i,:) = flowMatrix(i,:) * sendCap / totalOutflow;
        end
    end
end

function updatedVehicles = add_demand(currentVehicles, maxVehicles, cellIDs, trafficDemand, currentTime, timeStep)

    updatedVehicles = currentVehicles;
    timeTolerance = timeStep / 3600.0;  % Convert to hours
    
    % Check if demand table has time column
    if ~ismember('time', trafficDemand.Properties.VariableNames)
        return;
    end
    
    % Filter demand for current time window
    relevantRows = trafficDemand.time >= currentTime & ...
                   trafficDemand.time < currentTime + timeTolerance;
    relevantDemand = trafficDemand(relevantRows, :);
    
    % Add demand to each origin cell
    for i = 1:height(relevantDemand)
        originCell = relevantDemand.origin_cell(i);
        demand = relevantDemand.demand(i);  % vehicles/hour
        
        % Find cell index
        cellIdx = find(cellIDs == originCell, 1);
        
        if ~isempty(cellIdx)
            % Convert demand from vehicles/hour to vehicles per time step
            vehiclesToAdd = demand * (timeStep / 3600.0);
            
            % Add vehicles up to maximum capacity
            spaceAvailable = maxVehicles(cellIdx) - updatedVehicles(cellIdx);
            vehiclesAdded = min(vehiclesToAdd, spaceAvailable);
            updatedVehicles(cellIdx) = updatedVehicles(cellIdx) + vehiclesAdded;
        end
    end
end

function updatedVehicles = update_state(currentVehicles, flowMatrix, maxVehicles)

    nCells = length(currentVehicles);
    updatedVehicles = currentVehicles;
    
    for i = 1:nCells
        % Calculate outflow from cell i
        outflow = sum(flowMatrix(i,:));
        
        % Calculate inflow to cell i
        inflow = sum(flowMatrix(:,i));
        
        % Update vehicles: current - outflow + inflow
        updatedVehicles(i) = currentVehicles(i) - outflow + inflow;
        
        % Enforce constraints
        updatedVehicles(i) = max(0, min(updatedVehicles(i), maxVehicles(i)));
    end
end

function plot_results(densityHistory, timeHistory, cellIDs, cellLengths)

    figure('Position', [100, 100, 1200, 800]);
    
    % Plot 1: Density over time for selected cells
    subplot(2, 1, 1);
    hold on;
    legendEntries = {};
    
    for i = 1:length(cellIDs)
        cellID = cellIDs(i);
        cellIdx = find(cellIDs == cellID, 1);
        
        if ~isempty(cellIdx)
            plot(timeHistory, densityHistory(:, cellIdx), 'LineWidth', 1.5);
            legendEntries{end+1} = sprintf('Cell %d', cellID);
        end
    end
    
    hold off;
    xlabel('Time (hours)', 'FontSize', 12);
    ylabel('Density (vehicles/km)', 'FontSize', 12);
    title('Traffic Density over Time', 'FontSize', 14, 'FontWeight', 'bold');
    legend(legendEntries, 'Location', 'eastoutside', 'FontSize', 10);
    grid on;
    
    % Plot 2: Total vehicles in network
    subplot(2, 1, 2);
    totalVehicles = densityHistory * cellLengths;
    plot(timeHistory, totalVehicles, 'b-', 'LineWidth', 2);
    xlabel('Time (hours)', 'FontSize', 12);
    ylabel('Total Vehicles in Network', 'FontSize', 12);
    title('Total Network Occupancy', 'FontSize', 14, 'FontWeight', 'bold');
    grid on;

    % Additional plot: Density heatmap
    figure('Position', [100, 100, 1200, 600]);
    
    % Get indices for cells to plot
    % plotIndices = zeros(length(cellIDs), 1);
    % for i = 1:length(cellIDs)
    %     plotIndices(i) = find(cellIDs == cellIDs(i), 1);
    % end
    
    imagesc(timeHistory, 1:length(cellIDs), densityHistory(:, cellIDs)');
    colorbar;
    xlabel('Time (hours)', 'FontSize', 12);
    ylabel('Cell', 'FontSize', 12);
    title('Density Heatmap', 'FontSize', 14, 'FontWeight', 'bold');
    yticks(1:length(cellIDs));
    yticklabels(cellIDs);
    colormap('jet');
end

% Define cell IDs
cellIDs = [2108, 2109, 2110, 2111, 2113, 2114, 2115, 2116, 2118, 2119, ...
           2120, 2121, 2122, 2124, 2125, 2126, 2127, 2128, 2129, 2130, ...
           2131, 2132, 2134, 2135, 2136, 2203, 2210, 2215];

% Load data
distanceMatrix = load_distance_matrix('distance_matrix.csv', cellIDs) * 1.60934; % Convert from miles to kilometers
trafficDemand = readtable('traffic_demand.csv');

% Traffic parameters
params.freeFlowSpeed = 83;          % km/h  
params.congestionWaveSpeed = 19.2;    % km/h 
params.jamDensity = 135;            % vehicles/km  
params.maxFlow = 2200;              % vehicles/hour
params.timeStep = 86400;               % seconds
params.criticalDensity = params.maxFlow / params.freeFlowSpeed;
initialDensity = 0.2 * params.jamDensity * ones(length(cellIDs), 1);  % 20% of jam density (light traffic)

duration = 600;  % hours

nCells = length(cellIDs);
nSteps = floor(duration * 3600 / params.timeStep);

% Calculate cell properties
cellLengths = calculate_cell_lengths(distanceMatrix);
maxVehicles = cellLengths * params.jamDensity;
criticalVehicles = cellLengths * params.criticalDensity;

% Initialize state
currentVehicles = initialDensity .* cellLengths;
currentDensity = initialDensity;

% Initialize history tracking
densityHistory = zeros(nSteps, nCells);
flowHistory = cell(nSteps, 1);
timeHistory = zeros(nSteps, 1);

for step = 1:nSteps
    currentTime = (step - 1) * params.timeStep / 3600.0;  % hours
    
    % Add traffic demand
    currentVehicles = add_demand(currentVehicles, maxVehicles, cellIDs, ...
                                  trafficDemand, currentTime, params.timeStep);
    
    % Compute flows between cells
    flowMatrix = compute_flows(currentVehicles, cellLengths, maxVehicles, ...
                               criticalVehicles, distanceMatrix, params);
    
    % Update state
    currentVehicles = update_state(currentVehicles, flowMatrix, maxVehicles);
    currentDensity = currentVehicles ./ cellLengths;
    
    % Record history
    densityHistory(step, :) = currentDensity';
    flowHistory{step} = flowMatrix;
    timeHistory(step) = currentTime;
    
    % Print progress
    if mod(step, max(1, floor(nSteps/10))) == 0
        fprintf('Progress: %.1f%%\n', 100 * step / nSteps);
    end
end

fprintf('Simulation complete!\n');

% Plot results
plot_results(densityHistory, timeHistory, cellIDs, cellLengths);

% Calculate summary statistics
totalVehicles = densityHistory * cellLengths;
[maxVehicles_total, maxIdx] = max(totalVehicles);
peakTime = timeHistory(maxIdx);

fprintf('\n=== Summary Statistics ===\n');
fprintf('Peak network occupancy: %.0f vehicles at time %.2f hours\n', ...
        maxVehicles_total, peakTime);

% Average density per cell
avgDensities = mean(densityHistory, 1);
for i = 1:nCells
    fprintf('Cell %d average density: %.2f vehicles/km\n', ...
            cellIDs(i), avgDensities(i));
end